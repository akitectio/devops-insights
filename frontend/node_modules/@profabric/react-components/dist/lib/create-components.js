const NODE_MODE = false;
const DEV_MODE = true;
const reservedReactProperties = new Set(['children', 'localName', 'ref', 'style', 'className']);
const listenedEvents = new WeakMap();
const addOrUpdateEventListener = (node, event, listener) => {
    let events = listenedEvents.get(node);
    if (events === undefined) {
        listenedEvents.set(node, (events = new Map()));
    }
    let handler = events.get(event);
    if (listener !== undefined) {
        if (handler === undefined) {
            events.set(event, (handler = { handleEvent: listener }));
            node.addEventListener(event, handler);
        }
        else {
            handler.handleEvent = listener;
        }
    }
    else if (handler !== undefined) {
        events.delete(event);
        node.removeEventListener(event, handler);
    }
};
const setProperty = (node, name, value, old, events) => {
    const event = events === null || events === void 0 ? void 0 : events[name];
    if (event !== undefined && value !== old) {
        addOrUpdateEventListener(node, event, value);
        return;
    }
    node[name] = value;
    if ((value === undefined || value === null) && name in HTMLElement.prototype) {
        node.removeAttribute(name);
    }
};
export const createComponent = ({ react: React, tagName, elementClass, events, displayName, }) => {
    const eventProps = new Set(Object.keys(events !== null && events !== void 0 ? events : {}));
    if (DEV_MODE) {
        for (const p of reservedReactProperties) {
            if (p in elementClass.prototype && !(p in HTMLElement.prototype)) {
                console.warn(`${tagName} contains property ${p} which is a React reserved ` +
                    `property. It will be used by React and not set on the element.`);
            }
        }
    }
    const ReactComponent = React.forwardRef((props, ref) => {
        const prevPropsRef = React.useRef(null);
        const elementRef = React.useRef(null);
        const reactProps = {};
        const elementProps = {};
        for (const [k, v] of Object.entries(props)) {
            if (reservedReactProperties.has(k)) {
                reactProps[k === 'className' ? 'class' : k] = v;
                continue;
            }
            if (eventProps.has(k) || k in elementClass.prototype) {
                elementProps[k] = v;
                continue;
            }
            reactProps[k] = v;
        }
        if (!NODE_MODE) {
            React.useLayoutEffect(() => {
                if (elementRef.current === null) {
                    return;
                }
                for (const prop in elementProps) {
                    setProperty(elementRef.current, prop, props[prop], prevPropsRef.current ? prevPropsRef.current[prop] : undefined, events);
                }
                prevPropsRef.current = props;
            });
            React.useLayoutEffect(() => {
                var _a;
                (_a = elementRef.current) === null || _a === void 0 ? void 0 : _a.removeAttribute('defer-hydration');
            }, []);
        }
        if (NODE_MODE) {
            if (React.createElement.name === 'litPatchedCreateElement' &&
                Object.keys(elementProps).length) {
                reactProps['_$litProps$'] = elementProps;
            }
        }
        else {
            reactProps['suppressHydrationWarning'] = true;
        }
        return React.createElement(tagName, Object.assign(Object.assign({}, reactProps), { ref: React.useCallback((node) => {
                elementRef.current = node;
                if (typeof ref === 'function') {
                    ref(node);
                }
                else if (ref !== null) {
                    ref.current = node;
                }
            }, [ref]) }));
    });
    ReactComponent.displayName = displayName !== null && displayName !== void 0 ? displayName : elementClass.name;
    return ReactComponent;
};
